<p>We did a Bugzilla security release today, to fix some holes responsibly disclosed to us by <a href="http://www.checkpoint.com/">Check Point Vulnerability Research</a>, to whom we are very grateful. The most serious of them would allow someone to create and control an account for an arbitrary email address they don’t own. If your Bugzilla gives group permissions based on someone’s email domain, as some do, this could be a privilege escalation.</p>
<p>(<b>Update 2014-10-07 05:42 BST</b>: to be clear, this pattern is most commonly used to add “all people in a particular company” to a group, using an email address regexp like <code>.*@mozilla.com$</code>. It is used this way on bugzilla.mozilla.org to allow Mozilla Corporation employees access to e.g. Human Resources bugs. Membership of the Mozilla security group, which has access to unfixed vulnerabilities, is done on an individual basis and could not be obtained using this bug. The same is true of BMO admin privileges.)</p>
<p>These bugs are actually quite interesting, because they seem to represent a new Perl-specific security problem. (At least, as far as I’m aware it’s new, but perhaps we are about to find that everyone knows about it but us. <b>Update 2014-10-08 09:20 BST</b>: <a href="http://seclists.org/vulnwatch/2006/q4/6">everything old is new again</a>; but the level of response, including changes to CGI.pm, suggest that this had mostly faded from collective memory.) This is how it works. I’m using the <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1074812">most serious bug</a> as my example. The somewhat less serious bugs caused by this pattern were XSS holes. (Check Point are going to be presenting on this vulnerability at the <a href="http://events.ccc.de/category/31c3/">31st Chaos Communications Congress</a> in December in Hamburg, so check their analysis out too.)</p>
<p>Here’s the vulnerable code:</p>
<pre>
my $otheruser = Bugzilla::User-&gt;create(&#123;
    login_name =&gt; $login_name, 
    realname   =&gt; $cgi-&gt;param('realname'), 
    cryptpassword =&gt; $password});
</pre>
<p>This code creates a new Bugzilla user in the database when someone signs up. <code>$cgi</code> is an object representing the HTTP request made to the page.</p>
<p>The issue is a combination of two things. Firstly, the <code>$cgi-&gt;param()</code> call is context-sensitive – it can <a href="http://perldoc.perl.org/CGI.html#FETCHING-THE-VALUE-OR-VALUES-OF-A-SINGLE-NAMED-PARAMETER:">return a scalar or an array</a>, <a href="https://metacpan.org/source/LEEJO/CGI-4.04/lib/CGI.pm#L452">depending on the context</a> in which you call it – i.e. the type of the variable you assign the return value to. The ability for functions to do this is a Perl “do what I mean” feature.</p>
<p>Let’s say you called a page as follows, with 3 instances of the same parameter:</p>
<pre>
index.cgi?foo=bar&amp;foo=baz&amp;foo=quux
</pre>
<p>If you call <code>param()</code> in an array context (the @ sigil represents a variable which is an array), you get an array of values:</p>
<pre>
@values = $cgi-&gt;param('foo');
--&gt;
['bar', 'baz', 'quux']
</pre>
<p>If you call it in a scalar context (the $ sigil represents a variable which is a scalar), you get a single value, probably the first one:</p>
<pre>
$value = $cgi-&gt;param('foo'); 
--&gt;
'bar'
</pre>
<p>So what context is it being called in, in the code under suspicion? Well, that’s exactly the problem. It turns out that functions called during hash value assignment are evaluated in a list context. However, when the result comes back, that value or those values are assigned to be part of uthe hash as if they were a set of individual, comma-separated scalars. I suspect this behaviour exists because of the close relationship of lists and hashes; it allows you to do stuff like:</p>
<pre>
my @array = ("foo", 3, "bar", 6);
my %hash = @array;
--&gt;
&#123; "foo" =&gt; 3, "bar" =&gt; 6 }
</pre>
<p>Therefore, when assigning the result of a function call as a hash value, if the return value is a single scalar, all goes as you would expect, but if it’s an array, the second and subsequent values end up being added as key/value pairs in the hash as well. This allows an attacker to override values already in the hash (specified earlier), which may have already been validated, with values controlled by them. In our case, <code>real_name</code> can be any string, so doesn’t need validation, but <code>login_name</code> most definitely does, and it already has been by the time this code is called.</p>
<p>So, in the case of the problematic code above, something like:</p>
<pre>
index.cgi?realname=JRandomUser&amp;realname=login_name&amp;realname=admin@mozilla.com
</pre>
<p>would end up overriding the already-validated <code>login_name</code> variable, giving the attacker control of the value used in the call to <code>Bugzilla::User-&gt;create()</code>. Oops.</p>
<p>We found 15 instances of this pattern in our code, four of which were exploitable to some degree. If you maintain a Perl web application, you may want to audit it for this pattern. Clearly, CGI.pm <code>param()</code> calls are the first thing to look for, but it’s possible that this pattern could occur with other modules which use the same context-sensitive return feature. The generic fix is to require the function call to be evaluated in scalar context:</p>
<pre>
my $otheruser = Bugzilla::User-&gt;create(&#123;
    login_name =&gt; $login_name, 
    realname   =&gt; <b>scalar</b> $cgi-&gt;param('realname'), 
    cryptpassword =&gt; $password});
</pre>
<p>I’d say it might be wise to not ever allow hash values to be assigned directly from functions without a call to <code>scalar</code>.</p>